{"version":3,"sources":["components/Cell/index.tsx","components/Board/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Cell","props","useState","classes","setClasses","useEffect","status","className","onClick","index","Board","cells","map","cell","data","BOARD_SIZE","MAX_MINES","Math","sqrt","isLeftColumn","isRightColumn","isTopRow","isBottomRow","rowSize","App","score","setScore","gameover","setGameover","win","setWin","setCells","mineCount","i","isMine","random","console","log","push","mine","generateMines","checkMine","validIndex","some","hitMine","neighborMines","count","countNeighbors","unknownCount","filter","reduce","sum","cur","updateCells","updateStatus","selectStatus","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e049a99f.chunk.js","sourcesContent":["import { useEffect, useState } from 'react';\n\nexport const Cell = (props:any) => {\n\n  const [classes, setClasses] = useState<string>(\"\");\n\n  useEffect(() => setClasses(props.status), [props.status]);\n\n  const onClick = (index:number) => {\n      props.onClick(index);\n  };\n  return <div className={\"Cell \" + classes} onClick={() => onClick(props.index)}></div>;\n}","import { Cell } from \"../Cell\";\n\nexport const Board = (props:any) => {\n\n  return (\n  <div className=\"Board\">\n    {\n      props.cells.map(\n        (cell:any) => <Cell \n          key={cell.index} \n          index={cell.index} \n          onClick={props.onClick} \n          status={cell.data.status}\n        ></Cell>)\n    }\n  </div>\n)}","import './App.css';\nimport { Board } from './components/Board';\nimport { useEffect, useState } from 'react';\n\nconst BOARD_SIZE = 25;\nconst MAX_MINES = Math.sqrt(BOARD_SIZE) - 1;\nconst POINTS_INCREMENT = 100;\nconst POINTS_WIN = 500;\n\nconst isLeftColumn = (index:number) => {\n  const rowSize = Math.sqrt(BOARD_SIZE);\n  return (index % rowSize) === 0;\n}\n\nconst isRightColumn = (index:number) => {\n  const rowSize = Math.sqrt(BOARD_SIZE);\n  return ((index + 1) % rowSize) === 0;\n}\n\nconst isTopRow = (index:number) => {\n  const rowSize = Math.sqrt(BOARD_SIZE);\n  return (index < rowSize);\n}\n\nconst isBottomRow = (index:number) => {\n  const rowSize = Math.sqrt(BOARD_SIZE);\n  return (index >= BOARD_SIZE - rowSize);\n}\n\nfunction App() {\n  const [score, setScore] = useState(0);\n  const [gameover, setGameover] = useState(false);\n  const [win, setWin] = useState(false);\n  const [cells, setCells] = useState<any>([]);\n\n  const generateMines = () => {\n    let cells = [];\n    let mineCount = 0;\n    \n    for(let i=0; i < BOARD_SIZE; i++)\n    {\n      let isMine = false;\n      if(Math.random() < 0.2 && mineCount < MAX_MINES){\n        isMine = true;\n        mineCount++;\n      }\n\n      console.log(mineCount);\n      cells.push({\n        index: i,\n        data: {\n          mine: isMine,\n          status: 'unknown'\n        }\n      });\n    }\n    return cells;\n  }\n\n  useEffect(() => setCells(generateMines()),[]);\n\n  const checkMine = (index:number) => {\n    const validIndex = (index + BOARD_SIZE) % BOARD_SIZE;\n    return cells.some((cell:any) => {\n      return (cell.index === validIndex && cell.data.mine)\n    });\n  }\n\n  const countNeighbors = (index:number) => {\n    const rowSize = Math.sqrt(BOARD_SIZE);\n    let count = 0;\n\n    if(!isLeftColumn(index) && checkMine(index - 1)) count += 1;\n    if(!isRightColumn(index) && checkMine(index + 1)) count += 1;\n\n    if(!isTopRow(index) && checkMine(index - rowSize)) count += 1;\n    if(!isBottomRow(index) && checkMine(index + rowSize)) count += 1;\n\n    if(!isTopRow(index) && !isLeftColumn(index) && checkMine(index - rowSize - 1)) count += 1;\n    if(!isTopRow(index) && !isRightColumn(index) && checkMine(index - rowSize + 1)) count += 1;\n    if(!isBottomRow(index) && !isRightColumn(index) && checkMine(index + rowSize + 1)) count += 1;\n    if(!isBottomRow(index) && !isLeftColumn(index) && checkMine(index + rowSize - 1)) count += 1;\n\n    return count;\n  }\n\n  const updateStatus = (index:number, status:string) => {\n    const updateCells = cells.map((cell:any) => {\n      if(cell.index === index){\n        return {\n          index: cell.index, \n          data: {\n            mine: cell.mine,\n            status: status\n          }\n        }\n      }else{\n        return cell;\n      }\n    })\n    setCells(updateCells);\n  }\n\n  const selectStatus = (hitMine: boolean, neighborMines: number) => {\n    let status = '';\n    if (hitMine){\n      status = 'exploded';\n    } else if(neighborMines === 0){\n      status = 'clear';\n    } else if(neighborMines === 1){\n      status = 'warning';\n    } else if(neighborMines > 1){\n      status = 'danger';\n    }\n    return status;\n  }\n\n  const countUnknown = () => {\n    return cells.filter(\n      (cell:any) => cell.data.status === 'unknown'\n    ).reduce(\n      (sum: number , cur: any) => sum + 1, 0\n    )\n  }\n\n  const countMines = () => {\n    return cells.filter(\n      (cell:any) => cell.data.mine\n    ).reduce(\n      (sum: number , cur: any) => sum + 1, 0\n    )\n  }\n\n  const onClick = (index:number) => {\n    if (gameover || win) return;\n\n    const hitMine = checkMine(index);\n    setScore(hitMine ? score : score + POINTS_INCREMENT);\n\n    const neighborMines = countNeighbors(index);\n    const unknownCount = countUnknown();\n    const mineCount = countMines();\n\n    console.log(unknownCount);\n    updateStatus(index, selectStatus(hitMine, neighborMines));\n\n    if(unknownCount <= mineCount + 1){\n      setWin(true);\n      setScore(score + POINTS_WIN);\n    }\n\n    if(hitMine) setGameover(true);\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        {win && !gameover ? \"You won! - \" : \"\"}\n        {gameover ? \"Game over - \" : \"\"}\n        Score: {score}\n      </header>\n      <div className=\"Board-container\">\n        <Board cells={cells} onClick={onClick}></Board>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}