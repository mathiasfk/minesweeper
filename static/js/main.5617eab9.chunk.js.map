{"version":3,"sources":["types/CellStatus.ts","components/Cell/index.tsx","components/Board/index.tsx","components/Header/index.tsx","state/GameStateManagement.ts","components/Controls/index.tsx","Game.tsx","index.tsx"],"names":["CellState","getClassName","status","neighboringMines","variableClass","Danger","Cell","props","className","onClick","index","onContextMenu","e","onRightClick","preventDefault","Board","gridStyle","gridTemplateColumns","repeat","Math","sqrt","size","style","cells","map","cell","data","Header","isWin","isGameover","score","highScore","winStreak","mines","generateGameState","numMines","generateMines","win","gameover","mineCount","RangeError","xSize","Array","from","length","_","i","x","y","floor","mine","Unknown","currentCount","isMine","random","updateRevealedCellState","cellData","newData","Object","assign","countNeighboringMines","Clear","isWinCondition","gameState","filter","c","Flagged","analyzedCell","isNeighbor","self","other","includes","revealNeighboringClearCells","revealClearCells","updatedCells","clearedCells","newClearedCells","normalizedIndex","Controls","onClickNext","onClickRestart","initalGameState","Game","useState","setGameState","saveGameState","localStorage","setItem","JSON","stringify","initializeGame","useCallback","serializedGameState","getItem","parse","useEffect","prevState","newState","forEach","Exploded","revealCell","flagCell","newSize","pow","newMines","round","MAX_SIZE","newGame","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5617eab9.chunk.js","sourcesContent":["export enum CellState {\r\n    Unknown, \r\n    Clear,\r\n    Danger,\r\n    Exploded,\r\n    Flagged,\r\n}","import \"./cell.css\";\r\nimport { CellState } from '../../types/CellStatus';\r\n\r\ntype Props = {\r\n  index: number,\r\n  onClick: (index:number) => void,\r\n  onRightClick: (index:number) => void,\r\n  status: CellState,\r\n  neighboringMines?: number,\r\n}\r\n\r\nconst getClassName = (status: CellState, neighboringMines?: number) => {\r\n  let variableClass = '';\r\n  if (status === CellState.Danger){\r\n    variableClass = `${CellState[status]}${neighboringMines || ''}`;\r\n  }else{\r\n    variableClass = CellState[status];\r\n  }\r\n  return `Cell  ${variableClass}`;\r\n}\r\n\r\nexport const Cell: React.FC<Props> = props => {\r\n  return (\r\n    <div data-testid=\"cell\" \r\n        className={getClassName(props.status, props.neighboringMines)}\r\n        onClick={() => props.onClick(props.index)}\r\n        onContextMenu={(e) => {props.onRightClick(props.index); e.preventDefault();}}>\r\n          <p>{props.neighboringMines}</p>\r\n    </div>);\r\n}","import \"./board.css\";\r\nimport { CellData } from \"../../types/CellData\";\r\nimport { Cell } from \"../Cell\";\r\n\r\ntype Props = {\r\n  size:number,\r\n  cells:CellData[], \r\n  onClick:(index:number) => void,\r\n  onRightClick:(index:number) => void,\r\n}\r\n\r\nexport const Board = (props:Props) => {\r\n\r\n  const gridStyle = {\r\n    gridTemplateColumns: 'auto '.repeat(Math.sqrt(props.size))\r\n  }\r\n\r\n  return (\r\n  <div className=\"Board\" style={gridStyle} data-testid=\"board\">\r\n    {\r\n      props.cells.map(\r\n        cell => <Cell \r\n          key={cell.index} \r\n          index={cell.index} \r\n          onClick={props.onClick} \r\n          onRightClick={props.onRightClick}\r\n          status={cell.data.status}\r\n          neighboringMines={cell.data.neighboringMines}\r\n        >\r\n        </Cell>)\r\n    }\r\n  </div>\r\n)}","type Props = {\r\n    isWin: boolean,\r\n    isGameover: boolean,\r\n    score: number,\r\n    highScore: number,\r\n    winStreak: number,\r\n    mines: number,\r\n}\r\n\r\nexport function Header(props: Props){\r\n    return (\r\n    <header className=\"App-header\" data-testid=\"header\">\r\n        {props.isWin && !props.isGameover ? \"You won! - \" : \"\"}\r\n        {props.isGameover ? \"Game over - \" : \"\"}\r\n        Score: {props.score}\r\n        <br/>\r\n        High score: {props.highScore}\r\n        <br/>\r\n        Win streak: {props.winStreak}\r\n        <br/>\r\n        Mines on this game: {props.mines}\r\n  </header>)\r\n}","import { CellData } from \"../types/CellData\";\r\nimport { CellState } from \"../types/CellStatus\";\r\nimport { GameState } from \"../types/GameState\";\r\n\r\nexport const generateGameState = (\r\n    size: number, \r\n    numMines: number, \r\n    score?: number,\r\n    highScore?: number,\r\n    winStreak?: number,\r\n) => {\r\n    const newGame: GameState = {\r\n        size: size,\r\n        cells: generateMines(size, numMines),\r\n        mines: numMines,\r\n        score: score || 0,\r\n        highScore: highScore || 0,\r\n        win: false,\r\n        winStreak: winStreak || 0,\r\n        gameover: false,\r\n    }\r\n    return newGame;\r\n}\r\n\r\nexport const generateMines = (size: number, mineCount: number) => {\r\n    if (mineCount > size){\r\n        throw RangeError(\"mineCount should not be larger than size\")\r\n    }\r\n    const xSize = Math.sqrt(size);\r\n    const cells: CellData[] = Array.from({length: size}, (_, i) => ({\r\n        index: i,\r\n        x: i % xSize,\r\n        y: Math.floor(i/xSize),\r\n        data: {\r\n            mine: false,\r\n            status: CellState.Unknown\r\n        }\r\n    }));\r\n    let currentCount = 0;\r\n    \r\n    while(currentCount < mineCount){\r\n        for(let i=0; i < size; i++)\r\n        {\r\n            if (currentCount >= mineCount){\r\n                break;\r\n            }\r\n            if(!cells[i].data.mine){\r\n                const isMine = Math.random() < 0.2\r\n                cells[i].data.mine = isMine;\r\n                if (isMine) currentCount++;\r\n            }\r\n        }\r\n    }\r\n    return cells;\r\n}\r\n\r\nexport const revealCell = (prevState: GameState, index: number) => {\r\n    if(prevState.win || prevState.gameover){\r\n        return prevState;\r\n    }\r\n\r\n    let newState = Object.assign({}, prevState);\r\n    newState.cells.forEach(c => {\r\n        if(c.index === index && c.data.status !== CellState.Flagged){\r\n            if (c.data.mine){\r\n                c.data.status = CellState.Exploded\r\n                newState.gameover = true;\r\n            }else{\r\n                if (c.data.status === CellState.Unknown){\r\n                    c = updateRevealedCellState(c, prevState.cells, index);\r\n                    newState.score += 100;\r\n                    if(c.data.status === CellState.Clear){\r\n                        newState.cells = revealClearCells(prevState.cells, index);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    })\r\n    if (isWinCondition(newState)){\r\n        newState.win = true;\r\n        newState.winStreak++;\r\n        if (newState.score > newState.highScore){\r\n            newState.highScore = newState.score;\r\n        }\r\n    }\r\n    return newState;\r\n}\r\n\r\nconst updateRevealedCellState = (cellData: CellData, cells: CellData[], index: number) => {\r\n    const newData = Object.assign({}, cellData);\r\n    const mines = countNeighboringMines(cells, index);\r\n    newData.data.status = mines > 0 ? CellState.Danger : CellState.Clear;\r\n    newData.data.neighboringMines = mines;\r\n    return newData;\r\n}\r\n\r\nexport const isWinCondition = (gameState: GameState) => {\r\n    return !gameState.gameover && (\r\n        gameState.cells.filter(c => c.data.status === CellState.Unknown).length\r\n        + gameState.cells.filter(c => c.data.status === CellState.Flagged).length\r\n        === gameState.mines);\r\n}\r\n\r\nexport const flagCell = (prevState: GameState, index: number) => {\r\n    if(prevState.win || prevState.gameover){\r\n        return prevState;\r\n    }\r\n\r\n    let newState = Object.assign({}, prevState);\r\n    newState.cells.forEach(c => {\r\n        if(c.index === index){\r\n            c.data.status = c.data.status === CellState.Flagged ? CellState.Unknown : CellState.Flagged;\r\n        }\r\n    });\r\n    return newState;\r\n}\r\n\r\nexport const countNeighboringMines = (cells: CellData[], index: number) => {\r\n    const analyzedCell = cells[index];\r\n\r\n    return cells\r\n    .filter(c => isNeighbor(analyzedCell, c))\r\n    .filter(c => c.data.mine).length\r\n}\r\n\r\nconst isNeighbor = (self: CellData, other: CellData) => {\r\n    const x = self.x;\r\n    const y = self.y;\r\n    return ([x-1, x, x+1].includes(other.x) && [y-1, y+1].includes(other.y)) \r\n        || ([x-1, x+1].includes(other.x) && y === other.y);\r\n}\r\n\r\nexport const revealNeighboringClearCells = (cells: CellData[], index: number) => {\r\n    const analyzedCell = cells[index];\r\n\r\n    return cells\r\n    .map(c => {\r\n        if(isNeighbor(analyzedCell, c) && c.data.status !== CellState.Flagged && !c.data.mine){\r\n            return updateRevealedCellState(c, cells, c.index);\r\n        }\r\n        return c;\r\n    })\r\n}\r\n\r\nexport const revealClearCells = (cells: CellData[], index: number) => {\r\n    let updatedCells = cells;\r\n    let clearedCells = cells.filter(c => c.data.status === CellState.Clear).length;\r\n    let newClearedCells = 0;\r\n    while(clearedCells !== newClearedCells){\r\n        clearedCells = newClearedCells;\r\n        for (let i = 0; i < cells.length; i++){\r\n            const normalizedIndex = i % cells.length;\r\n            if(cells[normalizedIndex].data.status === CellState.Clear){\r\n                updatedCells = revealNeighboringClearCells(cells, normalizedIndex);\r\n            }\r\n        }\r\n        newClearedCells = cells.filter(c => c.data.status === CellState.Clear).length;\r\n    }\r\n    return updatedCells;\r\n}","import \"./controls.css\";\r\nimport { GameState } from \"../../types/GameState\"\r\n\r\ntype Props = {\r\n    gameState: GameState,\r\n    onClickNext: () => void,\r\n    onClickRestart: () => void,\r\n}\r\n\r\nexport const Controls: React.FC<Props> = (props) => {\r\n    return (\r\n    <div>\r\n        {props.gameState.win && \"Congratulations!\"}\r\n        {props.gameState.gameover && \"Better luck next time...\"}\r\n        <div className=\"Button-container\">\r\n            {props.gameState.win && <button className=\"Button next\" onClick={props.onClickNext}>Next game</button>}\r\n        </div>\r\n        <div className=\"Button-container\">\r\n            {props.gameState.gameover && <button className=\"Button restart\" onClick={props.onClickRestart}>Restart</button>}\r\n        </div>\r\n    </div>)\r\n}","import \"./Game.css\";\r\nimport { Board } from \"./components/Board\";\r\nimport { useCallback, useEffect, useState } from \"react\";\r\nimport { Header } from \"./components/Header\";\r\nimport { GameState } from \"./types/GameState\";\r\nimport { flagCell, generateGameState, revealCell } from \"./state/GameStateManagement\";\r\nimport { Controls } from \"./components/Controls\";\r\n\r\nconst INITIAL_SIZE = 9;\r\nconst INITIAL_MINES = 1;\r\nconst MAX_SIZE = 400;\r\nconst MAX_MINES = MAX_SIZE/2;\r\n\r\nconst initalGameState: GameState = {\r\n    size: 0,\r\n    cells: [],\r\n    mines: 0,\r\n    score: 0,\r\n    highScore: 0,\r\n    win: false,\r\n    winStreak: 0,\r\n    gameover: false,\r\n}\r\n\r\nfunction Game() {\r\n\r\n    const [gameState, setGameState] = useState<GameState>(initalGameState);\r\n\r\n    const saveGameState = (gameState: GameState) => {\r\n      setGameState(gameState);\r\n      localStorage.setItem(\"gameState\", JSON.stringify(gameState));\r\n    }\r\n\r\n    const initializeGame = useCallback(() => {\r\n      const serializedGameState = localStorage.getItem(\"gameState\");\r\n      if (serializedGameState){\r\n        saveGameState(JSON.parse(serializedGameState))\r\n      }else {\r\n        saveGameState(generateGameState(INITIAL_SIZE, INITIAL_MINES));\r\n      }\r\n    },[]);\r\n\r\n    const onClickUpdateState = (index: number) => {\r\n        saveGameState(revealCell(gameState, index));\r\n    }\r\n\r\n    const onRightClickUpdateState = (index: number) => {\r\n      saveGameState(flagCell(gameState, index));\r\n  }\r\n\r\n    const onClickNext = () => {\r\n      let newSize =  Math.pow(Math.sqrt(gameState.size) + 1, 2);\r\n      if (newSize > MAX_SIZE) newSize = MAX_SIZE;\r\n\r\n      let newMines =  Math.round(gameState.mines * 1.5);\r\n      if (newMines > MAX_MINES) newMines = MAX_MINES;\r\n\r\n      const newGame = generateGameState(\r\n        newSize, \r\n        newMines,\r\n        gameState.score,\r\n        gameState.highScore,\r\n        gameState.winStreak,\r\n      )\r\n      saveGameState(newGame);\r\n    }\r\n\r\n    const onClickRestart = () => {\r\n        const newGame = generateGameState(\r\n            INITIAL_SIZE,\r\n            INITIAL_MINES,\r\n            0,\r\n            gameState.highScore,\r\n            0,\r\n        )\r\n        saveGameState(newGame);\r\n    }\r\n\r\n    useEffect(() => initializeGame(), [initializeGame]);\r\n\r\n    return (\r\n    <div className=\"App\">\r\n      <Header\r\n        isWin={gameState.win}\r\n        isGameover={gameState.gameover}\r\n        score={gameState.score}\r\n        winStreak={gameState.winStreak}\r\n        highScore={gameState.highScore}\r\n        mines={gameState.mines}\r\n      />\r\n      <div className=\"Board-container\">\r\n        <Board size={gameState.size} cells={gameState.cells} onClick={onClickUpdateState} onRightClick={onRightClickUpdateState}></Board>\r\n      </div>\r\n      <Controls gameState={gameState} onClickNext={onClickNext} onClickRestart={onClickRestart}/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Game;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport Game from './Game';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Game />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);"],"sourceRoot":""}